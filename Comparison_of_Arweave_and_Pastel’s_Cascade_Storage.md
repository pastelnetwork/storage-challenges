# Comparison of Arweave and Pastel’s Cascade Storage Layer 
The purpose of this document is to give a brief overview of some of the design differences between Arweave and Pastel in terms of how data is stored and retrieved, how decentralization is achieved, the degree of censorship resistance, the economic incentives for network participants, etc.

First, a disclaimer: Arweave is a complex project and we do not claim to have expert knowledge of all aspects of it. We have read the Arweave [Yellow Paper](https://www.arweave.org/yellow-paper.pdf) and believe that we understands the basics, at least enough to describe how it differs from Pastel’s storage layer in key ways.


## Fundamental Philosophical Differences:

At a high level, Pastel’s design is based on starting with a very firm foundation for everything, which is to build on top of the Bitcoin core codebase (in fact, we actually built on top of the Z-Cash codebase, but this is essentially just the Bitcoin codebase with the addition of shielded transactions). Bitcoin has been around the longest and has demonstrated the best long-term security record of any crypto project; in addition, it is also the most decentralized by far.  Our basic design is to keep most of the core Bitcoin functionality intact in terms of the basic currency functionality, so that PSL coins are transacted in the same way as Bitcoin. 

The way we have approached building on top of this foundation is to create a series of “tickets” which are in fact written to the blockchain using coin transactions. These tickets contain identifiers that allows us to link them to data stored in the parallel storage layer. That means that the low-level code is familiar, and you can interact with the network at the currency level without ever knowing about how the tickets work. Thus there is a clear division between the parts of the system responsible for maintaining the ledger (i.e., which addresses control which tokens) and for storing the actual file data in the storage layer. 

The way mining (i.e., new block creation) works is also fairly similar to Bitcoin, with most of the security in the network arising from the proof-of-work computations There are also some aspects of proof-of-stake in Pastel as well, since the Supernodes that actually store data in the storage layer must control a minimum number of PSL coins, but the vast bulk of newly created coins are distributed to miners in proportion to their compute power. 

All of this has the following implications:


- Anyone who is very familiar with how Bitcoin works on a technical level will be very comfortable with Pastel and will have strong intuitions for how it works.
- The core currency functionality will have the same rock solid performance and security of the most refined blockchain in existence.
- All the various tools and services for working with Bitcoin can, with minimal changes, be made to work with Pastel, at least at the currency level (for example, services such as explorers, mining pools, etc.)
- Experienced security researchers and audit firms have a better chance of finding and remediating security problems, versus when they are working on a completely new and original system with no previous operational history to evaluate.

By comparison, Arweave essentially starts from scratch, throwing out the entire engineering experience and learnings from Bitcoin. Indeed, Arweave gets rid of the central idea of Bitcoin altogether, the blockchain itself; at its core, the Bitcoin blockchain is a series of blocks in the form of a linked list, with each block connected to the previous block. By introducing the concept of a “recall block”, Arweave makes new blocks depend not just on the previous block but also on arbitrary blocks in the blockchain history, which makes reasoning about the system a lot more complicated. Even more, Arweave doesn’t have the clear separation between the functionality of the native currency token and the data storage itself, which are effectively “co-mingled”. 

That means that any experience or intuition users and developers have for Bitcoin and other classical blockchain designs goes out the window, and we instead are faced with a much more inscrutable design that is much harder to reason about from first principles or by analogy. In an attempt to create productive incentives for network participants from a game-theoretic perspective, Arweave’s design allows for a large degree of discretion and choice on the part of node operators as to what data they will store. This discretion opens the door to a whole host of potential attack vectors that undermine the censorship resistance of the network. 

In contrast, Pastel’s design philosophy does not permit *any* discretion or choice on the part of network participants, nor does it rely on random chance; instead, everything in Pastel is completely deterministic, with the entropy required for security coming indirectly from the PoW computations. This means that no nodes can predict what will happen in future blocks in terms of which nodes will be selected to store which files, or which nodes will be selected to issue or respond to storage challenges. This means that they can’t undermine the overall network without controlling the vast majority of nodes in the network.


## Specific Implementation Differences for Storage

We have already discussed some essential differences, but now we can get into more details, particularly about how data is stored, retrieved, and verified on the network.

In order to create a new Arweave block of transactions (containing both ledger entries for the currency token and arbitrary stored data), a node on Arweave must have knowledge of the corresponding “recall block”. Thus, only nodes that already have that block locally can compete with each other to produce the new block. Unlike with Bitcoin, where every full node stores every block from the very beginning, and thus has full knowledge of the entire state of the system at any given point, Arweave gets rid of this concept, and allows nodes to store whichever blocks they want to. 

Because of its dependency on recall blocks, this creates an incentive for nodes to store as many blocks as possible locally, since this will allow them to compete on the greatest number of new blocks. Furthermore, this creates an additional incentive for nodes to store the “rarest” blocks (i.e., the historical blocks that are mirrored by the fewest number of nodes in the network), since if any of these “rare” blocks are selected as a recall block, there will be less competition to create that new block. In contrast, the blocks that are stored by the largest number of nodes will have a corresponding lower profit potential, since if these are selected as recall blocks, there will be excessively high competition to create the new block.

Arweave may have had good intentions in choosing this approach; indeed, it allows them to claim that their protocol is somehow optimal in a game theoretical sense, since if all node operators are totally rational and driven purely by the profit motive, they will each individually optimize the set of blocks they store locally, resulting in good global performance (i.e., the network should constantly adjust so that “over-provisioned” data is stored more efficiently on fewer nodes, and “under-provisioned” data is mirrored to more nodes to make it more robust). The problem with this approach, however, is that it gives node operators too much flexibility and power to manipulate the network if they are not acting according to profit motives. In essence, if you give a user the chance to choose something, then you have to worry that they will find some clever way of choosing that undermines your goals for network security and reliability/decentralization.

To give an illustrative example of what we are talking about, in Pastel’s design, during each new block, all Supernodes are put into a rank ordering based on a deterministic computation which compares the previous block hash to the ID of the Supernode; this way, all Supernodes can independently compute this ordering and agree on it without requiring any central coordinator. The computation they do is called [XOR Distance](https://en.wikipedia.org/wiki/Kademlia#:~:text=XOR%20was%20chosen%20because%20it,to%20A%20are%20the%20same), and basically lets you assign a “distance” between any two strings of text—in this case, the strings are the previous block hash (which is an emergent property of the PoW system, and thus impossible for anyone to predict or control) and the Supernode's “PastelID” string, which is generated for the Supernode when it is created and then fixed in place (the PastelID is actually the public key in a public/private key pair, used as a persistent identifier for all nodes in the network). The 3 Supernodes with the highest rank in the current block are then designated as the “registering Supernodes” and are responsible for, among other things, transmitting the data from the user to the rest of the network. 

Because of the way this works and the inherent unpredictable nature of the previous block hash, unless an attacker controls the vast bulk of Supernodes, it will be impossible for them to do anything to ensure that they can control all of the top 3 ranked Supernodes. And if even one of the top 3 Supernodes is “honest”, then it would disagree with the other potentially dishonest Supernodes, essentially forcing a “do over” to try it again where all 3 Supernodes come up with responses that agree with each other. In contrast, if we instead used some other mechanism for selecting the top ranked Supernodes that allowed for the Supernode operators to influence the outcome in some way (say, by allowing Supernode operators to periodically vote on which Supernodes are the most “reliable” or “trusted” or anything like that), then it opens up attack vectors where an attacker can undermine or corrupt the protocol without already having majority control over the network (i.e., without owning a super-majority of all Supernodes on the network), as we will explain in more detail below. 


## Simplified Overview of Pastel’s Storage Layer

At a high level, Pastel’s storage layer takes an input file—say for example, a 1mb image file—and then generates an overprovisioned collection of what we call “symbol files” that can be collected to reconstruct the original file. Concretely, the original 1mb file might turn into 12mb worth of 50kb symbol files. This is accomplished by means of the [Raptor-Q](https://www.rfc-editor.org/rfc/rfc6330.html) encoding scheme. 

These symbol files have a very important property: they are fungible. This means that, if you are trying to reconstruct the original 1mb file, you can just collect any of the 50kb symbol files (as long as you haven’t seen that exact symbol file already), and once you have collected slightly more than 1mb worth of distinct symbol files, you will be able to reconstruct the original file. 

That is, we aren’t turning the original 1mb file into a bunch of disjoint (non-overlapping) chunks, so that you need to collect all of them to get the file back. This approach of using disjoint chunks, which is how BitTorrent works, always results in the potential for there to be a “rarest” chunk that is only stored by a few of the nodes. This is why it’s a common occurrence with “under-seeded” BitTorrent links to get the file to 99% completion but then get stuck because you can’t find any nodes that will send you those last few chunks that you need. With our scheme in contrast, *any* chunk (i.e., a symbol file) helps you to reconstruct the file, as long as that chunk is new to you. 

Because we “overprovision” by generating a lot more chunks than would strictly be required to reconstruct the file (e.g., we create 12mb worth of chunks for a 1mb image file in our example, creating a 12x overprovisioning), and because each of these chunks is furthermore stored by 5 different nodes, we get a large degree of robustness. That means that large portions of the network could go down for any reason, or some portion of Supernodes could corrupt or lose chunks (even intentionally, in the case of malicious node operators), and we will still have a very good chance of reconstructing the file perfectly.

Furthermore, our design allows for “self-healing” after a non-critical loss of data, where any missing chunks (symbol files) can be automatically regenerated by remaining functional Supernodes to replace any that may be lost. This is done by a Supernode reconstructing the original file from the set of remaining chunks, and then using this original file together with the “seed” used in the encoding (which is stored directly in the Pastel blockchain in the relevant ticket) to get a perfect new copy of the exact same symbol file that was lost, which can be verified by checking the hash against the list of hashes stored in the network at the time the file was first uploaded (this set of hashes is itself stored in the same storage layer, with the hash of this “file list” file included in the relevant blockchain ticket). 

But how can the nodes of the network determine which of them should store which symbol files in a decentralized way, without any single coordinator telling each node which file to store? We again use the same basic idea of XOR distance. We take the text string for each Supernode’s PastelID as our first string, and then for each of the 50kb symbol files, we take the SHA256 hash of the file as the second string, and compute the XOR between these two strings for every symbol file and every Supernode. This gives us a distance table that we can use to determine the 5 “closest” Supernodes to any given symbol file, and these are precisely the symbol files that each Supernode is responsible for storing and serving to the network (given an authorized request, signed by a valid owner of that file); that is, those files where the Supernode is in the set of the 5 closest Supernodes to that file.  

Not only does each Supernode know which files it is responsible for storing, but every other Supernode also knows this (or rather, can *compute* it on the fly), so they can all check each other for compliance (something we will get into below when we discuss Pastel’s storage challenge system). Furthermore, this system allows the network to dynamically adapt in the face of changing circumstances. Suppose that 3 new Supernodes join the network suddenly. For certain files that are already stored in the storage layer, one or more of the 3 new Supernodes might have a PastelID that is “closer” in terms of XOR distance to the files (specifically, the file hashes) than any of the existing 5 “closest” Supernodes. In that case, the new Supernode automatically takes on responsibility for storing that file, and the existing Supernode that is pushed out of the “top 5 closest” group is no longer required to store the file.

The same logic works in reverse when a Supernode disappears from the network, which they can of course do at any time given that the network is permissionless and decentralized. A similar process also applies when new files are added to the storage layer, and these are automatically assigned to the closest Supernodes. Again, the “news” about the changing responsibilities of each Supernode in terms of the precise set of files they are responsible for storing doesn’t need to be communicated to the nodes by any centralized server, since all Supernodes can monitor when Supernodes are created and destroyed and when new files are added to the storage layer, and based on this data, they can easily compute this information about which files everyone is supposed to be storing.
 
But all of this doesn’t matter if we the network has no way of enforcing or checking that Supernodes are correctly complying with their responsibilities, and this is where the system of storage challenges comes into play. In brief, Pastel’s storage challenge system comes down to “random” spot checks performed by each Supernode periodically on a peer Supernode to verify that this peer is storing the files it is supposed to be storing. Because the Supernodes can’t predict in advance which files they will be quizzed on, they have no other choice but to store all of them, or else they risk failing to respond in time to a challenge and then are punished by withholding of some of the payments they would otherwise receive as their share of the network’s mining block reward. 

The reason for the quote marks around the word random in the previous paragraph is that, in fact, none of this is random, but rather completely deterministic, with the Supernodes having absolutely no discretion or control over which files they issue challenges for, which Supernodes they send the challenge to, etc. And the reason for this is obvious; if you let Supernodes choose, then if a single party controlled a lot of Supernodes, they could cheat by never accusing their own Supernodes (or even the Supernodes controlled by their friends) of failing a storage challenge. Or they could try to get more of the block reward by maliciously accusing unrelated Supernode peers of failing challenges; when those innocent Supernodes are punished by having their network payments skipped, it could increase the short term payments to the malicious accusing Supernodes and thus giving a profit motive to malicious behavior.

It’s beyond the scope of this document to go into all the details of how storage challenges work at a technical level, but they provide an efficient solution to the problem in that they send as little data over the network between Supernodes as possible while still fully verifying that files are being stored and served correctly by all participants in the network, and most importantly, cannot be “gamed” by any Supernode operators because of the “deterministic randomness” that is injected into the system by basing everything on the hash of the previous block, which no one can predict in advance, but which everyone can securely and reliably verify using the blockchain data itself. 


## A Comparison of Censorship Resistance

Suppose that there are a total of 100 Supernodes, and that an attacker controls 10 of them. Assume that the attacker wants to disrupt the network’s operations, so that files can’t be reliably stored and served by users, but that they don’t even have a profit incentive in doing so. That is, they won’t make any more PSL by their actions (say, by causing other Supernodes to receive less, as in the example above), but are acting maliciously purely out of “spite”. This isn’t so hard to believe; imagine that someone has stored a file that is objectionable to the Chinese government, which wants to suppress it. Or even that a competing crypto project to Pastel wants to hurt us to beat the competition. 

Because our hypothetical attacker only controls 10% of the Supernodes, given the various controls and procedures described in the previous section, they have virtually no chance of being able to really hurt the network. Because if a user requests access to a file, the other 90% of the Supernodes should already have between them more than enough symbol files to reconstruct the file. The attacker can’t do anything to increase their odds of getting just their Supernodes “closer” to all of the relevant symbol files that are related to the particular file they want to suppress.

Remember, this is all based on the XOR distance of the Supernode’s PastelID, which is constant and doesn’t change over the life of the Supernode. In addition, there is a minimum “startup time” associated with changing everything by transferring the collateral PSL coins to a new Supernode in order to generate a new PastelID which might be “closer” to any of the symbol files of interest to the attacker. This all means that, even if the attacker acts maliciously to refuse to send any symbol files that are requested from it (they can’t get away with sending corrupted or modified versions of the symbol files, since the other Supernodes know what the file hashes of each symbol file should be), this would still never prevent the user from getting the file from the rest of the "honest” Supernodes.  
 
OK, so why is this better than Arweave? Well, because Arweave uses an incentive based “market” system to allocate file storage, where nodes can decide however they want (but presumably based on what will earn them the most money on the network) which files they should store. As described earlier, there is a built-in incentive for nodes in Arweave to replicate the rarest files, since these are the most profitable on average. 

As Arweave explains in their [Yellow Paper](https://www.arweave.org/yellow-paper.pdf): 

*“The PoA algorithm also incentives miners to store `rare' blocks more than it incentivizes them to store well-replicated blocks. This is because when a rare block is chosen, miners with access to it compete amongst a smaller number of miners in the PoW puzzle for the same level of reward. As a consequence of this, miners that prefer to store rarer blocks on average receive a greater*
*reward over time, all else being equal.”*

But suppose again that the Chinese government or similar state actor is trying to suppress a file it doesn’t like on Arweave. 

One strategy this attacker could take is to create a large set of “sock-puppet” nodes, so that other participants on the network have no way of knowing that a bunch of nodes which they might assume are independent are actually all controlled by the attacker. Then, using these sock-puppet nodes, the attacker could store tons of copies of the files in question, thus driving down the attractiveness of storing those files so low that none of the other honest nodes want to store them, since they could do much better for themselves by storing rare files. This process could be done slowly over time until the vast majority of nodes storing the relevant files are under control of the attacker. Only then, the attacker could spring into action, suppressing the file by refusing to correctly respond with the relevant data when requested by users and nodes on the network. 

Of course, Arweave has mechanisms to verify that nodes do what they are supposed to, but in this case the attacker might be perfectly happy to lose a bunch of AR coins as a penalty or fine for not sending the data when asked (especially if they always promptly respond to every other data request). The network can’t be too punitive anyway, because there are always going to be “explainable” service interruptions from broken machines and network connectivity issues, which could lead to too many “false positive” situations. In this way, a powerful attacker could quietly and effectively suppress data on the network. And it all stems from giving the nodes a choice in which files they store—a choice that they can abuse to further their ends if they don’t care about maximizing their profit on the network but instead have ulterior motives.

Ironically, Arweave claims in their Yellow Paper that allowing nodes to choose somehow makes their network *more* censorship resistant:

*"The Arweave protocol avoids making it an obligation to store everything, which in turn allows each node to decide for itself which blocks and transactions to store. This increases the censorship resistance of the network as nodes are not forced to store material they don't want to.”*

This is a false dichotomy, because there are other better alternatives besides the straw-man “every node stores every file” approach and the “any node can choose to store whatever they want to”. A better solution in fact is to have *some* of the nodes responsible for *some* of the files, and to choose all this in a provably secure and efficient way that can be validated independently by each node doing local computations in a trustless manner.

As Arweave says in their Yellow Paper: 

*“Here, you will discover how the blockweave enables miners to democratically decide which storage content they collectively do or do not wish to store inside the network.”*

The problem is that we do NOT want democracy here, which is extremely vulnerable to all manner of attacks. Instead, we want an all-powerful absolute monarchy, but not where the monarch is a Supernode or other network participant (selected, say, on a round-robin basis, or worst of all, through elections), but where *the network protocol itself is the monarch.* Because the network protocol will always be fair and impartial, since it is executing deterministic code, and because that code is all ultimately “steered” by the emergent proof-of-work side of the network, which everyone can reasonably agree is a fair system and impossible for anyone to control or predict or otherwise “game”. 

And like any good monarch, it should have a reliable and efficient “secret police” to ensure that everyone is playing by the rules (by always observing everyone else’s behavior as checking for compliance). And that secret police is comprised of whatever portion of the Supernodes in the network that are truly independent and “honest”: they are running the official, unmodified Pastel software, and they are not manipulating anything else to interfere with the ordinary operations of the network, such as DDOS attacking the IP addresses of other Supernodes.  

Even if a relatively large portion of the Supernodes are controlled by an attacker, the remainder that are honest can still “sound the alarm” about any malicious behavior by any of the attacker’s Supernodes and re-route around the now untrusted Supernodes by not requesting symbol files from them and adding them to a shared “ban list” to warn other nodes about trusting the malicious nodes.

Importantly, any successful attempts to attack the network would have to be general attacks that would undermine the network as a whole—not attacks against a particular file, which are much easier to undertake while risking less in terms of financial penalties. And the reason for this again is in how there is no choice available to network participants as to which files they must store to be considered in full compliance with their obligations to the network arising from the network protocol; thus, they have to “attack” all files at the same time, a much harder thing to do.



## Using Tricks to Get Undue Influence Over the Network

One of Arweave’s big ideas is to use game theory, where nodes make choices based on what makes the most sense financially. This is exemplified in what Arweave calls the *Wildfire* scheme, described in the following passage from the Yellow Paper; What sounds like a good metaphor for ensuring efficient network operation suffers from an analogous problem to what we discussed in the previous section:

*“In the wildfire mechanic, a form of AIIA game (see section 6), each node in the Arweave network ranks its peers based on two primary factors. Firstly, the peer's generosity - sending new transactions and blocks, secondly, the peer's responsiveness - responding promptly to requests for information, in a similar mechanism to Bittorrent's optimistic tit-for-tat algorithm. The node then gossips preferentially to higher-ranked peers. This allows a node to rationalise its bandwidth allocation. It also has the effect of promoting pro-social behaviour on the part of nodes generally, given the practical implications of how every peer interacts with every other peer.”*

So they have nodes deciding which other nodes they should most interact with, so they can presumably optimize their profit potential by only communicating with the “good” nodes. That is, the nodes that have been sending them data faster, the ones that are “most generous”. The problem is that those “good nodes” might actually be malicious nodes that manipulate this mechanism to gain the upper hand. That is, an attacker could dedicate resources to getting the fastest, lowest latency machines around the world, build up a good reputation in the network by always responding quickly, and then on top of that, *running modified software that is “extra generous”.* That is, the attacker shares more than really makes financial sense, giving them a disproportionate influence on the network. By tricking other nodes into thinking they are good, the attacker lulls the network into a false sense of security. 

For example, an attacker could potentially control most or all of the machines that a typical node is checking first to see what’s happening on the network. Then at some future point, they can start acting maliciously, by obstructing network activities, selectively withholding messages or data, etc. In contrast, in Pastel, nodes can’t manipulate their standing through their own actions (other than avoiding getting banned for violating the rules) to change how much other nodes rely on their messages. A well intentioned idea for promoting “pro-social behaviour” turns into anti-social attacks by a committed and clever adversary. What is most important in a crypto currency project is **security**, not the “efficiency of markets” or some proof of how the “dominant strategy” is to follow the network protocol. This is a naïve view of security. Instead, you have to always assume to worst of all participants—not only that they will attempt to cheat and steal from other network participants, but also that they might just be out for wanton destruction with no financial gain, simply to vandalize and undermine.

This is a very tough standard, but we do have powerful tools to solve the problems. And that is to remove all the discretion from any important actions between nodes, and to systematically monitor all network activity to verify that all nodes are acting in accordance with the protocol. Instead of trying to make the basis of organization of activity on the network along the lines of maximizing profit, with every interaction based on making more money in the short term, in Pastel the financial incentive for the Supernodes is much simpler: simply follow the rules in general (so you don’t get banned by your peer Supernodes) and you will make the standard amount for a Supernode— an income which is presumably attractive enough to justify the investment of the 5 million of PSL required to collateralize a Supernode. Then, everyone is incentivized to ensure that everyone else is following the rules, and if not, to ban them (this is possible because all Supernodes can independently verify everything stored in any part of the system, and they constantly do that on a rolling basis through the storage challenge procedure).

But even if Supernodes in Pastel *are* malicious, there is limited damage they can do. They can never pile on various exploits and advantages like nodes in Arweave can, built up over time through “economically irrational behavior” to ensure that they can have an outsized impact on the immediate functioning of the overall network when the time comes—especially if they have a specific target in terms of a set of particularly sensitive files that they want to suppress. This is important, because that is the exact scenario that is most likely to occur; for most data on the network, no one would care enough to do anything 99.999% of the time. But for the high value target data, the leaked documents or whatever it is, it might make sense to “call in your chips” and harvest the accumulated goodwill you’ve earned in the Arweave network by being an “extra good node” that is “super generous and pro-social” for years at a time.  Because you can focus your efforts like a laser beam just on those particular files, you can have a huge impact relative to the risk and cost of the attack. 


